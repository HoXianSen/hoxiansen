[{"title":"怎么加快GitHub访问速度","url":"/2023/01/06/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%ABGitHub%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/","content":"由于某些特殊原因，导致Github总是有时抽风无法访问，这对我这种CV工程师来说简直是天大的打击。接下来介绍几种访问Github的方式。\n1. 使用镜像GitHub镜像地址：kgithub.com \n使用方式：当遇到GitHub链接打不开的时候，把链接中的github.com更换为kgithub.com后访问。\nPS：还有另一个镜像地址：hub.nuaa.cf ，但是这个比较慢，也不太容易记住，可以当做备用。\n2. 更改DNS当需要push时，使用镜像的方式会比较麻烦（有些镜像也不支持push），这时就需要使用到更改DNS的方式。\n这里推荐Github520 （镜像地址：https://kgithub.com/521xueweihan/GitHub520 ），这个GitHub项目会为我们提供最新的能访问到GitHub的IP地址。\n3. 梯子这里推荐v2ray ，速度慢，也不稳定，但对于我日常访问Google来说是够了，而且免费。\nPS：如果有流量和速度的VPN需求可以看看这个项目 。\n","categories":["Solution"],"tags":["Github","梯子"]},{"title":"链表反转","url":"/2023/03/03/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/","content":"反转链表需要3个本地变量\npre ：指向前一个节点\nt   ：当前节点\nnext：后一个节点\n\n\n反转步骤class Node &#123;    int value;    Node next;&#125;\n\n1、初始化变量Node pre = null;Node t = head;Node next = null;\n\n2、循环反转while(t!=null)&#123;    next = t.next;    t.next = pre;    pre = t;    t = next;&#125;\n\n完整代码import java.util.StringJoiner;public class ReverseLinkedList &#123;    public static void main(String[] args) &#123;        Node node = prepareNodeList();        printNodeList(node);        Node pre = null, t = node, next;        while (t != null) &#123;            next = t.next;            t.next = pre;            pre = t;            t = next;        &#125;        printNodeList(pre);    &#125;    static Node prepareNodeList() &#123;        int[] arr = new int[]&#123;2, 4, 5, 6, 7, 8, 9&#125;;        Node head = new Node(-1);        Node t = head;        for (int i : arr) &#123;            Node node = new Node(i);            t.next = node;            t = node;        &#125;        return head.next;    &#125;    static void printNodeList(Node node) &#123;        StringJoiner sj = new StringJoiner(&quot;--&gt;&quot;);        while (node != null) &#123;            sj.add(String.valueOf(node.x));            node = node.next;        &#125;        System.out.println(sj);    &#125;    static class Node &#123;        int x;        Node next;        Node(int x) &#123;            this.x = x;        &#125;    &#125;&#125;","categories":["算法"],"tags":["算法","链表"]},{"title":"Java中docx、xlsx、pptx转pdf的方法","url":"/2023/01/08/Java%E4%B8%ADdocx%E3%80%81xlsx%E3%80%81pptx%E8%BD%ACpdf%E7%9A%84%E6%96%B9%E6%B3%95/","content":"一、Windows环境调用Office或者WPS的COM接口引入jacob依赖\n下载jacob-1.20依赖包 并解压\n将其中的jar包安装到maven本地仓库（也可以直接在项目中引入jar包依赖） mvn install:install-file     -Dfile=&lt;/your/path/to/jacob.jar&gt;    -DgroupId=com.jacob    -DartifactId=jacob    -Dversion=1.20 -Dpackaging=jar\n把jacob-1.20-x64.dll和jacob-1.20-x86.dll拷贝至%JAVA_HOME%\\jre\\bin目录\n\n\n关于jacob的更多使用方式，可以参考MicroSoft的VBA文档 \n\n转换代码：public class JacobToPdfUtil &#123;    /**     * 转PDF格式值     */    private static final int WORD_FORMAT_PDF = 17;    private static final int EXCEL_FORMAT_PDF = 0;    private static final int PPT_FORMAT_PDF = 32;    private static final String PROGRAM_WORD_OFFICE = &quot;Word.Application&quot;;    private static final String PROGRAM_WORD_WPS = &quot;KWPS.Application&quot;;    private static final String PROGRAM_EXCEL_OFFICE = &quot;Excel.Application&quot;;    private static final String PROGRAM_EXCEL_WPS = &quot;KET.Application&quot;;    private static final String PROGRAM_PPT_OFFICE = &quot;PowerPoint.Application&quot;;    private static final String PROGRAM_PPT_WPS = &quot;KWPP.Application&quot;;    public static void wordToPdfByMsOffice(String inputFile, String pdfFile) throws IOException &#123;        wordToPdf(inputFile, pdfFile, PROGRAM_WORD_OFFICE);    &#125;    public static void wordToPdfByWps(String inputFile, String pdfFile) throws IOException &#123;        wordToPdf(inputFile, pdfFile, PROGRAM_WORD_WPS);    &#125;    private static void wordToPdf(String inputFile, String pdfFile, String program) throws IOException &#123;        ActiveXComponent app = null;        Dispatch doc = null;        try &#123;            // 创建一个word对象            app = new ActiveXComponent(program);            // 不可见打开word            app.setProperty(&quot;Visible&quot;, new Variant(false));            // 禁用宏            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));            // 获取文挡属性            Dispatch docs = app.getProperty(&quot;Documents&quot;).toDispatch();            // 调用Documents对象中Open方法打开文档，并返回打开的文档对象Document            doc = Dispatch.call(docs, &quot;Open&quot;, inputFile).toDispatch();            // word保存为pdf格式宏，值为17            Dispatch.call(doc, &quot;SaveAs&quot;, pdfFile, WORD_FORMAT_PDF);        &#125; catch (Throwable t) &#123;            throw new IOException(&quot;word转pdf失败&quot;, t);        &#125; finally &#123;            if (doc != null) &#123;                Dispatch.call(doc, &quot;Close&quot;, false);            &#125;            if (app != null) &#123;                app.invoke(&quot;Quit&quot;);            &#125;            // 关闭WINWORD.exe进程            ComThread.Release();        &#125;    &#125;    public static void excelToPdfByMsOffice(String inputFile, String pdfFile) throws IOException &#123;        excelToPdf(inputFile, pdfFile, PROGRAM_EXCEL_OFFICE);    &#125;    public static void excelToPdfByWps(String inputFile, String pdfFile) throws IOException &#123;        excelToPdf(inputFile, pdfFile, PROGRAM_EXCEL_WPS);    &#125;    private static void excelToPdf(String inputFile, String pdfFile, String program) throws IOException &#123;        ActiveXComponent app = null;        Dispatch excel = null;        try &#123;            app = new ActiveXComponent(program);            // 不可见打开excel            app.setProperty(&quot;Visible&quot;, new Variant(false));            // 禁用宏            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));            Dispatch workbooks = app.getProperty(&quot;Workbooks&quot;).toDispatch();            excel = Dispatch.call(workbooks, &quot;Open&quot;, inputFile).toDispatch();            Dispatch.call(excel, &quot;ExportAsFixedFormat&quot;, EXCEL_FORMAT_PDF, pdfFile);        &#125; catch (Throwable t) &#123;            throw new IOException(&quot;excel转pdf失败&quot;, t);        &#125; finally &#123;            if (excel != null) &#123;                Dispatch.call(excel, &quot;Close&quot;, false);            &#125;            if (app != null) &#123;                app.invoke(&quot;Quit&quot;);            &#125;            // 关闭WINWORD.exe进程            ComThread.Release();        &#125;    &#125;    public static void pptToPdfByMsOffice(String inputFile, String pdfFile) throws IOException &#123;        pptToPdf(inputFile, pdfFile, PROGRAM_PPT_OFFICE);    &#125;    public static void pptToPdfByWps(String inputFile, String pdfFile) throws IOException &#123;        pptToPdf(inputFile, pdfFile, PROGRAM_PPT_WPS);    &#125;    private static void pptToPdf(String inputFile, String pdfFile, String program) throws IOException &#123;        ActiveXComponent app = null;        Dispatch ppt = null;        try &#123;            // 创建一个ppt对象            app = new ActiveXComponent(program);            // 不能设置Visible=false。Hiding the application window is not allowed.            // 禁用宏            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));            // 获取文挡属性            Dispatch presentations = app.getProperty(&quot;Presentations&quot;).toDispatch();            // 调用Documents对象中Open方法打开文档，并返回打开的文档对象Document            // 文档：https://learn.microsoft.com/zh-cn/office/vba/api/powerpoint.presentations.open            ppt = Dispatch.call(presentations, &quot;Open&quot;, inputFile,                    true, // ReadOnly                    false, // Untitled指定文件是否有标题                    false // WithWindow指定文件是否可见            ).toDispatch();            Dispatch.call(ppt, &quot;SaveAs&quot;, pdfFile, PPT_FORMAT_PDF);        &#125; catch (Throwable t) &#123;            throw new IOException(&quot;ppt转换pdf失败&quot;, t);        &#125; finally &#123;            if (ppt != null) &#123;                Dispatch.call(ppt, &quot;Close&quot;);            &#125;            if (app != null) &#123;                app.invoke(&quot;Quit&quot;);            &#125;            // 关闭WINWORD.exe进程            ComThread.Release();        &#125;    &#125;&#125;\n\n二、Linux环境调用LibreOffice安装LibreOffice\n去LibreOffice下载页 下载对应Linux发行版的LibreOffice。\n解压后安装。 sudo dpkg -i DEBS/*.deb\n 或者 sudo yum install /RPMS/*.rpm\n增加中文字体，不然转换时中文会乱码。 # 检查系统中是否有中文字体fc-list :lang=zh\n 如果返回空，请按照这个文档 去安装中文字体。\n安装完成之后运行一下libreoffice7.3 --help，可能会提示库找不到。我在CentOS7系统安装时就遇到了libcairo.so.2，libcups.so.2，libSM.so.6这三个库找不到的问题，执行下面几条命令安装需要的库： yum install cairo -yyum install cups-libs -yyum install libSM -y\n 如果遇到其他库找不到的问题可以参考上面解决。\n\n转换代码：public class LibreOfficeToPdfUtil &#123;    public static void toPdf(String inputFile, String pdfFile) throws BootstrapException, Exception &#123;        XComponentContext context = Bootstrap.bootstrap();        XMultiComponentFactory serviceManager = context.getServiceManager();        Object desktop = serviceManager.createInstanceWithContext(&quot;com.sun.star.frame.Desktop&quot;, context);        XDesktop xDesktop = UnoRuntime.queryInterface(XDesktop.class, desktop);        XComponentLoader xComponentLoader = UnoRuntime.queryInterface(XComponentLoader.class, xDesktop);        PropertyValue hidden = new PropertyValue();        hidden.Name = &quot;Hidden&quot;;        hidden.Value = Boolean.TRUE;        XComponent xComponent = xComponentLoader.loadComponentFromURL(&quot;file:///&quot; + inputFile, &quot;_blank&quot;, 0, new PropertyValue[]&#123;hidden&#125;);        XStorable xStorable = UnoRuntime.queryInterface(XStorable.class, xComponent);        PropertyValue overwrite = new PropertyValue();        overwrite.Name = &quot;Overwrite&quot;;        overwrite.Value = Boolean.TRUE;        PropertyValue filterName = new PropertyValue();        filterName.Name = &quot;FilterName&quot;;        filterName.Value = &quot;writer_pdf_Export&quot;;        xStorable.storeToURL(&quot;file:///&quot; + pdfFile, new PropertyValue[]&#123;overwrite, filterName&#125;);        xDesktop.terminate();    &#125;&#125;\n\n运行时报错解决\ncom.sun.star.comp.helper.BootstrapException: no office executable found!解决办法：添加java参数-Xbootclasspath/a:/opt/libreoffice7.3/program/原因：启动时会从classpath中寻找soffice文件，所以得把soffice所在目录加到classpath中。\n\n可以通过readlink &#96;which libreoffice7.3&#96;看libreoffice安装在哪个目录。\n\n\n点运行后一直等待，5分钟后抛出BootstrapException异常原因：libreoffice进程启动失败。解决办法：可以在命令行运行一下libreoffice看看是否缺少库，然后参考上面安装步骤解决。\n\n转换之后的pdf中文显示方框原因：系统中缺少中文字体。解决办法：参考安装步骤添加中文字体。\n\n\n参考文档：\n\nlinux安装libreOffice \nConvert Microsoft Word to PDF - using Java and LibreOffice (UNO API) \nJava中常用的几种DOCX转PDF方法 \n\n","categories":["Java"],"tags":["Java","Jacob","LibreOffice","pdf"]},{"title":"Hexo进入离开页面动态修改标题","url":"/2023/03/06/Hexo%E8%BF%9B%E5%85%A5%E7%A6%BB%E5%BC%80%E9%A1%B5%E9%9D%A2%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A0%87%E9%A2%98/","content":"效果预览\n添加自定义Javascript文件找到博客根目录下的source文件夹，在里面创建一个js文件夹。在js文件夹中新建文件visibility_change.js\nvar originTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123;    if (document.hidden) &#123;        document.title = &#x27;(*σ´∀`)σ 我走噜~ &#x27; + originTitle;        if (titleTime != null) &#123;            clearTimeout(titleTime);        &#125;    &#125; else &#123;        document.title = &#x27;(*´∇｀*) 我来力~ &#x27; + originTitle;        titleTime = setTimeout(function () &#123;            document.title = originTitle;        &#125;, 2000);    &#125;&#125;);\n\n在主题配置文件中引入自定义js以我用的redefine主题为例，在_config.redefine.yml里面的inject引入。其他主题同理，参考对应主题的配置文档。\ninject:  enable: true  head:    - &lt;script src=&quot;/js/visibility_change.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  footer:\n注意：自定义js文件的引用路径是/js/xxx.js，而不是./js/xxx.js。\n","categories":["Solution"],"tags":["Hexo"]}]