[{"title":"怎么加快GitHub访问速度","url":"/2023/01/06/%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%ABGitHub%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/","content":"由于某些特殊原因，导致Github总是有时抽风无法访问，这对我这种CV工程师来说简直是天大的打击。接下来介绍几种访问Github的方式。\n1. 使用镜像GitHub镜像地址：kgithub.com \n使用方式：当遇到GitHub链接打不开的时候，把链接中的github.com更换为kgithub.com后访问。\nPS：还有另一个镜像地址：hub.nuaa.cf ，但是这个比较慢，也不太容易记住，可以当做备用。\n2. 更改DNS当需要push时，使用镜像的方式会比较麻烦（有些镜像也不支持push），这时就需要使用到更改DNS的方式。\n这里推荐Github520 （镜像地址：https://kgithub.com/521xueweihan/GitHub520 ），这个GitHub项目会为我们提供最新的能访问到GitHub的IP地址。\n3. 梯子这里推荐v2ray ，速度慢，也不稳定，但对于我日常访问Google来说是够了，而且免费。\nPS：如果有流量和速度的VPN需求可以看看这个项目 。\n","categories":["Solution"],"tags":["Github","梯子"]},{"title":"Java中docx、xlsx、pptx转pdf的方法","url":"/2023/01/08/Java%E4%B8%ADdocx%E3%80%81xlsx%E3%80%81pptx%E8%BD%ACpdf%E7%9A%84%E6%96%B9%E6%B3%95/","content":"一、Windows环境调用Office或者WPS的COM接口引入jacob依赖\n下载jacob-1.20依赖包 并解压\n将其中的jar包安装到maven本地仓库（也可以直接在项目中引入jar包依赖） mvn install:install-file     -Dfile=&lt;/your/path/to/jacob.jar&gt;    -DgroupId=com.jacob    -DartifactId=jacob    -Dversion=1.20 -Dpackaging=jar\n把jacob-1.20-x64.dll和jacob-1.20-x86.dll拷贝至%JAVA_HOME%\\jre\\bin目录\n\n\n关于jacob的更多使用方式，可以参考MicroSoft的VBA文档 \n\n转换代码：public class JacobToPdfUtil &#123;    /**     * 转PDF格式值     */    private static final int WORD_FORMAT_PDF = 17;    private static final int EXCEL_FORMAT_PDF = 0;    private static final int PPT_FORMAT_PDF = 32;    private static final String PROGRAM_WORD_OFFICE = &quot;Word.Application&quot;;    private static final String PROGRAM_WORD_WPS = &quot;KWPS.Application&quot;;    private static final String PROGRAM_EXCEL_OFFICE = &quot;Excel.Application&quot;;    private static final String PROGRAM_EXCEL_WPS = &quot;KET.Application&quot;;    private static final String PROGRAM_PPT_OFFICE = &quot;PowerPoint.Application&quot;;    private static final String PROGRAM_PPT_WPS = &quot;KWPP.Application&quot;;    public static void wordToPdfByMsOffice(String inputFile, String pdfFile) throws IOException &#123;        wordToPdf(inputFile, pdfFile, PROGRAM_WORD_OFFICE);    &#125;    public static void wordToPdfByWps(String inputFile, String pdfFile) throws IOException &#123;        wordToPdf(inputFile, pdfFile, PROGRAM_WORD_WPS);    &#125;    private static void wordToPdf(String inputFile, String pdfFile, String program) throws IOException &#123;        ActiveXComponent app = null;        Dispatch doc = null;        try &#123;            // 创建一个word对象            app = new ActiveXComponent(program);            // 不可见打开word            app.setProperty(&quot;Visible&quot;, new Variant(false));            // 禁用宏            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));            // 获取文挡属性            Dispatch docs = app.getProperty(&quot;Documents&quot;).toDispatch();            // 调用Documents对象中Open方法打开文档，并返回打开的文档对象Document            doc = Dispatch.call(docs, &quot;Open&quot;, inputFile).toDispatch();            // word保存为pdf格式宏，值为17            Dispatch.call(doc, &quot;SaveAs&quot;, pdfFile, WORD_FORMAT_PDF);        &#125; catch (Throwable t) &#123;            throw new IOException(&quot;word转pdf失败&quot;, t);        &#125; finally &#123;            if (doc != null) &#123;                Dispatch.call(doc, &quot;Close&quot;, false);            &#125;            if (app != null) &#123;                app.invoke(&quot;Quit&quot;);            &#125;            // 关闭WINWORD.exe进程            ComThread.Release();        &#125;    &#125;    public static void excelToPdfByMsOffice(String inputFile, String pdfFile) throws IOException &#123;        excelToPdf(inputFile, pdfFile, PROGRAM_EXCEL_OFFICE);    &#125;    public static void excelToPdfByWps(String inputFile, String pdfFile) throws IOException &#123;        excelToPdf(inputFile, pdfFile, PROGRAM_EXCEL_WPS);    &#125;    private static void excelToPdf(String inputFile, String pdfFile, String program) throws IOException &#123;        ActiveXComponent app = null;        Dispatch excel = null;        try &#123;            app = new ActiveXComponent(program);            // 不可见打开excel            app.setProperty(&quot;Visible&quot;, new Variant(false));            // 禁用宏            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));            Dispatch workbooks = app.getProperty(&quot;Workbooks&quot;).toDispatch();            excel = Dispatch.call(workbooks, &quot;Open&quot;, inputFile).toDispatch();            Dispatch.call(excel, &quot;ExportAsFixedFormat&quot;, EXCEL_FORMAT_PDF, pdfFile);        &#125; catch (Throwable t) &#123;            throw new IOException(&quot;excel转pdf失败&quot;, t);        &#125; finally &#123;            if (excel != null) &#123;                Dispatch.call(excel, &quot;Close&quot;, false);            &#125;            if (app != null) &#123;                app.invoke(&quot;Quit&quot;);            &#125;            // 关闭WINWORD.exe进程            ComThread.Release();        &#125;    &#125;    public static void pptToPdfByMsOffice(String inputFile, String pdfFile) throws IOException &#123;        pptToPdf(inputFile, pdfFile, PROGRAM_PPT_OFFICE);    &#125;    public static void pptToPdfByWps(String inputFile, String pdfFile) throws IOException &#123;        pptToPdf(inputFile, pdfFile, PROGRAM_PPT_WPS);    &#125;    private static void pptToPdf(String inputFile, String pdfFile, String program) throws IOException &#123;        ActiveXComponent app = null;        Dispatch ppt = null;        try &#123;            // 创建一个ppt对象            app = new ActiveXComponent(program);            // 不能设置Visible=false。Hiding the application window is not allowed.            // 禁用宏            app.setProperty(&quot;AutomationSecurity&quot;, new Variant(3));            // 获取文挡属性            Dispatch presentations = app.getProperty(&quot;Presentations&quot;).toDispatch();            // 调用Documents对象中Open方法打开文档，并返回打开的文档对象Document            // 文档：https://learn.microsoft.com/zh-cn/office/vba/api/powerpoint.presentations.open            ppt = Dispatch.call(presentations, &quot;Open&quot;, inputFile,                    true, // ReadOnly                    false, // Untitled指定文件是否有标题                    false // WithWindow指定文件是否可见            ).toDispatch();            Dispatch.call(ppt, &quot;SaveAs&quot;, pdfFile, PPT_FORMAT_PDF);        &#125; catch (Throwable t) &#123;            throw new IOException(&quot;ppt转换pdf失败&quot;, t);        &#125; finally &#123;            if (ppt != null) &#123;                Dispatch.call(ppt, &quot;Close&quot;);            &#125;            if (app != null) &#123;                app.invoke(&quot;Quit&quot;);            &#125;            // 关闭WINWORD.exe进程            ComThread.Release();        &#125;    &#125;&#125;\n\n二、Linux环境调用LibreOffice安装LibreOffice\n去LibreOffice下载页 下载对应Linux发行版的LibreOffice。\n解压后安装。 sudo dpkg -i DEBS/*.deb\n 或者 sudo yum install /RPMS/*.rpm\n增加中文字体，不然转换时中文会乱码。 # 检查系统中是否有中文字体fc-list :lang=zh\n 如果返回空，请按照这个文档 去安装中文字体。\n安装完成之后运行一下libreoffice7.3 --help，可能会提示库找不到。我在CentOS7系统安装时就遇到了libcairo.so.2，libcups.so.2，libSM.so.6这三个库找不到的问题，执行下面几条命令安装需要的库： yum install cairo -yyum install cups-libs -yyum install libSM -y\n 如果遇到其他库找不到的问题可以参考上面解决。\n\n转换代码：public class LibreOfficeToPdfUtil &#123;    public static void toPdf(String inputFile, String pdfFile) throws BootstrapException, Exception &#123;        XComponentContext context = Bootstrap.bootstrap();        XMultiComponentFactory serviceManager = context.getServiceManager();        Object desktop = serviceManager.createInstanceWithContext(&quot;com.sun.star.frame.Desktop&quot;, context);        XDesktop xDesktop = UnoRuntime.queryInterface(XDesktop.class, desktop);        XComponentLoader xComponentLoader = UnoRuntime.queryInterface(XComponentLoader.class, xDesktop);        PropertyValue hidden = new PropertyValue();        hidden.Name = &quot;Hidden&quot;;        hidden.Value = Boolean.TRUE;        XComponent xComponent = xComponentLoader.loadComponentFromURL(&quot;file:///&quot; + inputFile, &quot;_blank&quot;, 0, new PropertyValue[]&#123;hidden&#125;);        XStorable xStorable = UnoRuntime.queryInterface(XStorable.class, xComponent);        PropertyValue overwrite = new PropertyValue();        overwrite.Name = &quot;Overwrite&quot;;        overwrite.Value = Boolean.TRUE;        PropertyValue filterName = new PropertyValue();        filterName.Name = &quot;FilterName&quot;;        filterName.Value = &quot;writer_pdf_Export&quot;;        xStorable.storeToURL(&quot;file:///&quot; + pdfFile, new PropertyValue[]&#123;overwrite, filterName&#125;);        xDesktop.terminate();    &#125;&#125;\n\n运行时报错解决\ncom.sun.star.comp.helper.BootstrapException: no office executable found!解决办法：添加java参数-Xbootclasspath/a:/opt/libreoffice7.3/program/原因：启动时会从classpath中寻找soffice文件，所以得把soffice所在目录加到classpath中。\n\n可以通过readlink &#96;which libreoffice7.3&#96;看libreoffice安装在哪个目录。\n\n\n点运行后一直等待，5分钟后抛出BootstrapException异常原因：libreoffice进程启动失败。解决办法：可以在命令行运行一下libreoffice看看是否缺少库，然后参考上面安装步骤解决。\n\n转换之后的pdf中文显示方框原因：系统中缺少中文字体。解决办法：参考安装步骤添加中文字体。\n\n\n参考文档：\n\nlinux安装libreOffice \nConvert Microsoft Word to PDF - using Java and LibreOffice (UNO API) \nJava中常用的几种DOCX转PDF方法 \n\n","categories":["Java"],"tags":["Java","Jacob","LibreOffice","pdf"]},{"title":"链表反转","url":"/2023/03/03/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/","content":"反转链表需要3个本地变量\npre ：指向前一个节点\nt   ：当前节点\nnext：后一个节点\n\n\n反转步骤class Node &#123;    int value;    Node next;&#125;\n\n1、初始化变量Node pre = null;Node t = head;Node next = null;\n\n2、循环反转while(t!=null)&#123;    next = t.next;    t.next = pre;    pre = t;    t = next;&#125;\n\n完整代码import java.util.StringJoiner;public class ReverseLinkedList &#123;    public static void main(String[] args) &#123;        Node node = prepareNodeList();        printNodeList(node);        Node pre = null, t = node, next;        while (t != null) &#123;            next = t.next;            t.next = pre;            pre = t;            t = next;        &#125;        printNodeList(pre);    &#125;    static Node prepareNodeList() &#123;        int[] arr = new int[]&#123;2, 4, 5, 6, 7, 8, 9&#125;;        Node head = new Node(-1);        Node t = head;        for (int i : arr) &#123;            Node node = new Node(i);            t.next = node;            t = node;        &#125;        return head.next;    &#125;    static void printNodeList(Node node) &#123;        StringJoiner sj = new StringJoiner(&quot;--&gt;&quot;);        while (node != null) &#123;            sj.add(String.valueOf(node.x));            node = node.next;        &#125;        System.out.println(sj);    &#125;    static class Node &#123;        int x;        Node next;        Node(int x) &#123;            this.x = x;        &#125;    &#125;&#125;","categories":["算法"],"tags":["算法","链表"]},{"title":"Hexo进入离开页面动态修改标题","url":"/2023/03/06/Hexo%E8%BF%9B%E5%85%A5%E7%A6%BB%E5%BC%80%E9%A1%B5%E9%9D%A2%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%A0%87%E9%A2%98/","content":"效果预览\n添加自定义Javascript文件找到博客根目录下的source文件夹，在里面创建一个js文件夹。在js文件夹中新建文件visibility_change.js\nvar originTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123;    if (document.hidden) &#123;        document.title = &#x27;(*σ´∀`)σ 我走噜~ &#x27; + originTitle;        if (titleTime != null) &#123;            clearTimeout(titleTime);        &#125;    &#125; else &#123;        document.title = &#x27;(*´∇｀*) 我来力~ &#x27; + originTitle;        titleTime = setTimeout(function () &#123;            document.title = originTitle;        &#125;, 2000);    &#125;&#125;);\n\n在主题配置文件中引入自定义js以我用的redefine主题为例，在_config.redefine.yml里面的inject引入。其他主题同理，参考对应主题的配置文档。\ninject:  enable: true  head:    - &lt;script src=&quot;/js/visibility_change.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  footer:\n注意：自定义js文件的引用路径是/js/xxx.js，而不是./js/xxx.js。\n","categories":["Solution"],"tags":["Hexo"]},{"title":"循环队列的边界判定","url":"/2023/03/10/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E8%BE%B9%E7%95%8C%E5%88%A4%E5%AE%9A/","content":"引言循环队列通常使用数组来实现，需要定义队头head和队尾tail两个指针，在每次入队时tail++出队时head++。但是在判断队列空和满时总是想不明白，这里记录一下。\n指针初始化在初始化头尾指针时，有两种初始化方式：\n1. 头指针和尾指针分别指向对应的头尾节点int head=0, tail=-1;\n\n\n2. 头指针指向头节点，尾指针指向尾节点的下一个结点int head=0, tail=0;\n\n\n可以看到，不管是哪种初始化方式，队列空时和队列满时的头尾指针相对位置都是一样的。\n\n\n判断空、满在这种情况下怎么判断队列到底是空还是满呢？也有两种方式：\n1. 引入size字段，表示队列长度此时不论使用哪种初始化方式，都可以完全不管头尾指针的位置，直接使用size来判断。\n\n判断队列空：size==0;\n判断队列满：size==maxLength;\n\n2. head和tail只增不减与上面在入队（或出队）后需要tail=(tail+1)%maxLength不同，每次入队（或出队）后只需要tail++，而不用取余。这样的好处就是可以通过相减得到当前队列大小size，然后再通过size来判断队列的空和满。\n不同初始化方式的size计算\n\n对于第一种初始化方式：int head=0, tail=-1;，size=tail-head+1;\n对于第二种初始化方式：int head=0, tail=0;，size=tail-head。\n\n \n\nLeetCode链接622. 设计循环队列 \n","categories":["算法"],"tags":["算法","队列","数组"]},{"title":"CCF201312-4有趣的数","url":"/2023/05/11/CCF201312-4%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0/","content":"import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        //0 1 3        long[][][][] dp = new long[n + 1][2][2][2];        /*        000        001        100        101        110        111         */        // 初始条件下只有2（且首位数字只能是2）        dp[1][0][0][0] = 1;        for (int i = 2; i &lt;= n; i++) &#123;            dp[i][0][0][0] = dp[i - 1][0][0][0];            dp[i][0][0][1] = (dp[i - 1][0][0][1] + dp[i - 1][0][0][0]) % 1000000007;            dp[i][1][0][0] = (2 * dp[i - 1][1][0][0] + dp[i - 1][0][0][0]) % 1000000007;            dp[i][1][0][1] = (2 * dp[i - 1][1][0][1] + dp[i - 1][1][0][0] + dp[i - 1][0][0][1]) % 1000000007;            dp[i][1][1][0] = (2 * dp[i - 1][1][1][0] + dp[i - 1][1][0][0]) % 1000000007;            dp[i][1][1][1] = (2 * dp[i - 1][1][1][1] + dp[i - 1][1][0][1] + dp[i - 1][1][1][0]) % 1000000007;        &#125;        long res = dp[n][1][1][1];        System.out.println(res);    &#125;&#125;"}]